{"name":"Cauldron","tagline":"Parse secrets.yml to export environment variables fetched from a trusted store","body":"# cauldron\r\n\r\ncauldron provides an interface for\r\n\r\n* reading the **secrets.yml** format\r\n* fetching secrets from a trusted store\r\n* exporting their values to the environment\r\n\r\nParse secrets.yml to export environment variables fetched from a trusted store.\r\n\r\n## secrets.yml\r\n\r\nsecrets.yml defines a format for mapping environment variables to locations of\r\nsecrets.\r\n\r\n```yml\r\nAWS_ACCESS_KEY_ID: !var /aws/iam/user/robot/access_key_id\r\nAWS_PEM: !file /aws/iam/user/robot/pem_file\r\nENVIRONMENT: $environment\r\n```\r\n\r\nRunning an implementation of cauldron against this example file will\r\n\r\n1. Fetch the secret defined at `aws/iam/user/robot/access_key_id` in a secrets server and set the environment variable `AWS_ACCESS_KEY_ID` to the secret's value.\r\n2. The value of `AWS_PEM` will be the path to a temporary memory-mapped file that is cleaned up on exit of the process cauldron is wrapping.\r\n3. `ENVIRONMENT` will be interpolated at runtime by using cauldron's `-D` flag, like so: `cauldron -D '$environment=production'`. This flag can be specified multiple times.\r\n\r\n\r\n## Providers\r\n\r\nCauldron uses plug-and-play providers. A provider is any executable that satisfies this contract:\r\n\r\n* Accepts one argument, where a secret is located\r\n* Returns the value of the secret on stdout and exit code 0 if retrieval was successful.\r\n* Returns an error message on stderr and a non-0 exit code if retrieval was unsuccessful.\r\n\r\nProviders can be written in any language you prefer. They can be as simple as a shell script.\r\n\r\nWhen cauldron runs it will look for a provider in `/usr/libexec/cauldron/`. If there is one executable\r\nin this directory it will use it as the default provider. If the directory hold multiple executables\r\nyou will be prompted to select the one you want to use. You can set the provider with the `-p, --provider`\r\nflag to the CLI or via the environment variable `CAULDRON_PROVIDER`. If your provider is in a location\r\nnot on your `PATH` you will need to specify its full path.\r\n\r\nFor example, if you have multiple providers and want to use the one for [vault](https://vaultproject.io/), this is your command.\r\n\r\n```sh-session\r\n$ cauldron --provider /usr/libexec/cauldron/vault\r\n```\r\n\r\n## Usage\r\n\r\nBy default, cauldron will look for `secrets.yml` in the directory it is\r\ncalled from and export the secret values to the environment of the command it wraps.\r\n\r\n*Example*\r\n\r\nYou want to run script that requires AWS keys to list your EC2 instances.\r\n\r\nDefine your keys in a `secrets.yml` file\r\n\r\n```yml\r\nAWS_ACCESS_KEY_ID: aws/iam/user/robot/access_key_id\r\nAWS_SECRET_ACCESS_KEY: aws/iam/user/robot/secret_access_key\r\n```\r\n\r\nThe script uses the Python library [boto](https://pypi.python.org/pypi/boto), which looks for `AWS_ACCESS_KEY_ID`\r\nand `AWS_SECRET_ACCESS_KEY` in the environment.\r\n\r\n```python\r\nimport boto\r\nbotoEC2 = boto.connect_ec2()\r\nprint(botoEC2.get_all_instances())\r\n```\r\n\r\nWrap running this script in cauldron.\r\n\r\n```\r\ncauldron python listEC2.py\r\n```\r\n\r\n`python listEC2.py` is the command that cauldron wraps. Once this command exits\r\nand secrets in the environment are gone.\r\n\r\n### Flags\r\n\r\n`cauldron` supports a number of flags.\r\n\r\n**`-f <path>`** specify a location to a secrets.yml file.\r\n\r\n```\r\ncauldron -f /etc/mysecrets.yml\r\n```\r\n\r\n**`-D '$var=value'`** causes substitution of `value` to `$var`.\r\n\r\nYou can use the same secrets.yml file for different environments, using `-D` to\r\nsubstitute variables.\r\n\r\n*Example*\r\n\r\nsecrets.yml\r\n```yml\r\nAWS_ACCESS_KEY_ID: $environment/aws/iam/user/robot/access_key_id\r\n```\r\n\r\n```sh-session\r\n$ cauldron -D '$environment=development' env | grep AWS\r\nAWS_ACCESS_KEY_ID=mydevelopmentkey\r\n```\r\n\r\n**`-- yaml 'key:value'`** secrets.yml as a literal string\r\n\r\nA string in secrets.yml format can also be passed to cauldron.\r\n\r\n```sh-session\r\n$ cauldron --yaml 'MONGODB_PASS: db/dbname/password' chef-apply\r\n```\r\n\r\nThis will make `ENV['MONGODB_PASS']` available in your Chef run.\r\n\r\nView help and all flags with `cauldron -h`.\r\n\r\n## Development\r\n\r\nInstall dependencies\r\n\r\n```\r\nxargs -L1 go get <Godeps\r\n```\r\n\r\nRun the project with `go run *.go`.\r\n\r\n### Testing\r\n\r\nTests are written using [GoConvey](http://goconvey.co/).\r\nRun tests with `go test -v ./...` or `./test.sh` (for CI).\r\n\r\n### Building\r\n\r\nTo build 64bit versions for Linux, OSX and Windows:\r\n\r\n```\r\n./build.sh\r\n```\r\n\r\nBinaries will be placed in `pkg/`.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}